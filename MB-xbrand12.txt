#### Stručně ale věcně odpovězte na následující otázky: ######

1. Zkompilujte ref verzi kódu. Byla hlavní výpočetní smyčka kompilátorem automaticky vektorizována? 
Pokud ne, stručně popište proč a co vektorizaci brání.
Pokud ano, jaká je efektivita vektorizace? (0.5b)
=============================================================================
NE - problém při volání funkce mandelbrot(), kompilátor neví co přesně funkce dělá. 
Navíc ve funkci dochází k podmíněnému ukončení cyklu, což způsobuje rozdílné počty iterací pro vnější smyčku.

2. Kolika GFLOPS a GINTOPS dosahuje smyčka ve funkci mandelbrot u ref verze kódu při 
překladu s -O0 (žádné optimalizace) a -O3 (maximální optimalizace)? 
Byly použity FMA instrukce? Jak jste k tomu přišli? Jaká instrukční sada (IS) byla použita? (1b)
=============================================================================
- O0:
-- 1,17 GFLOPS
-- 0,29 GINTOPS
-- IS: AVX
-- FMA: ne

- O3:
-- 3,19 GFLOPS
-- 0,38 GINTOPS
-- IS: AVX
-- FMA: ano, konkrétně vfmad213ss


3. Přeložte ref verzi kódu s přepínačem -O0 (žádné optimalizace) a -O3 (maximální optimalizace). (2b)
- Co se stalo s paměťovými přístupy u smyček? Popište číslem s jednotkou/procentuálně kolik je paměťových vs. výpočetních instrukcí 
- Ukazuje se smyčka ve funkci mandelbrot v RoofLine modelu? Proč? (Nápověda: AI, Survey)
==============================================================================
- O0:
-- mandelbrot: paměťových 48%, výpočetních 7%
-- calculateMandelbrot: paměťových 67%, výpočetních 12%

- O3:
-- mandelbrot: paměťových 0%, výpočetních 81%
-- calculateMandelbrot: paměťových 42%, výpočetních 14%

Slovní vyjádření (1-2 krátké věty):
Po vektorizaci se využívají pouze registry a přístupy do paměti se minimalizovaly.
Smyčka se neukazuje, protože byla vložena přímo do těla calculateMandelbrot().


4. Přeložte program s -O0 (žádné optimalizace). Na jakou výkonostní linii v RoofLine modelu 
   cílíme s jednotlivými implementacemi? (1b)
   Uveďte název a výkonnost včetně jednotky.
==============================================================================
- ref: scalar add peak: 6,56 GFLOPS
- line: SP Vector Add Peak: 79,3 GFLOPS
- batch: SP Vector Add Peak: 79,3 GFLOPS


5. Jaká byla dosažena výkonnost v Intel Advisoru pro implementace ref, line a batch
(v GFLOPS) při použití přepínačů -O0 a -O3? (1b)
==============================================================================
- ref:
-- O0: 1.14 GFLOPS
-- O3: 3,03 GFLOPS

- line:
-- O0: 6,37 GFLOPS
-- O3: 21,25 GFLOPS

- batch:
-- O0: 5,40 GFLOPS
-- O3: 21,54 GFLOPS


6. Porovnejte implementaci referenčního rešení oproti "Line" a "Batch" implementaci. 
Jakým způsobem jsou načítána data, proč, a jaký to má vliv na výkon. (1b)
==============================================================================
- line: načtení celého řádku a zpracování více pixelů naráz => výrazně výkonnější a efektivnější 
než načítání po jednom pixelu jako v fer. Problém nastává pokud se celý výsledek nevejde do cache (snížení výkonu).
- batch: stejný princip jako u line, načítání dat po řádcích ale navíc ošteřený problém zarovnání 
dat na velikost cache. Je zajištěno, že se pracuje s blokem, který se do cache vejde => nejvyšší výkon.


7. Porovnejte Roofline všech modelů - Jaká je vaše aritmetická intenzita? 
Dokázali byste ji přibližně spočítat i ručně a jak? (1b)
============================================================================== 
Uvedeno pro -DUSE_O3=ON
- ref AI: 0,25  FLOP/Byte
- line AI: 0,336 FLOP/Byte
- batch AI: 0,311 FLOP/Byte

Přibližný výpočet: sečíst aritmetické operace pro jednu iteraci ve vnitřní smyčce
a podělit součtem všech paměťových přenosů v jedné iteraci (pouze do paměti, ne mezi registry)


8. Komentujte vliv velikosti cache na výkonnost a chování na větších 
velikostech domény. (1b)
==============================================================================
Velikost cache je zásadní, čím více dat, se kterými se aktuálně pracuje, se vejde do cache,
tím vyšší výkon, protože se nemusí přistupovat do paměti. Velmi časté přístupy do paměti
snižují výkon, protože se musí čekat na data. Na větších doménách, kde se nevejde celá struktura
do cache je nutné omezit množství pomoci cache blocking technik, aby nedocházelo k neustálému
přepisování cache.



9. Jaký vliv na výkonnost má symetrie? Lze tento rozdíl pozorovat v Intel Advisor? 
(nápověda: instrukce) (0.5b)
============================================================================== 
Při využití symetrie dochazi k vypoctu pouze u poloviny celkovych bodu, takže vypočetně je to
méně náročné ale v počtech přístupů k paměti se nic neliší, je potřeba tam hodnoty vložit všechny.
V Advisoru to znázorňuje nižší počet vykonaných instrukcí a dále poloviční potřebný čas na výpoče,
ale dvojnásobný datový provoz v dané smyčce.